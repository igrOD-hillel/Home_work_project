# 1. Организовиваете точку входа.
# 2. В точке входа передаете главную функцию.
# 3. Создаете какую-то функцию some_func, которая будет принимать позиционние и поименованние аргументи
#    (привильно организавать прием аргументов через args и kwargs). Єта функция должна поровну разделить все позиционние
#     аргументи на списки с равним количеством єлементов, чтоби хватило для всех ключей,
#     и она же должна создать словарь, ключами которого будут поименованние аргументи, а значениями,
#     полученние ранее списки. Функция должна вернуть словарь
# 4. Создать еще одну функцию load_dict(some_dict, json_path), которая принимает словарь и путь к json файлу. Функция
#    загружает словарь в соответствующий файл.
# 5. В главной функции визиваете, ранее созданную функцию some_func, передаете в нее 21 позиционний аргумент (21 задано
#    специально, чтоби получить некратное значение) и 5 поименованних аргументов (имя аргумента равно самому значению ),
#    пример, some_func(1,2,3,4,5, name = ‘name’, make = ‘make’).
# 6. Результати функции some_func присваиваете какой-то переменной и прокидиваете ее в функцию load_dict,
#    в єту же функцию передаете и путь
# 7. Результат скрипт сгенерирует json файл, с соответствующим контетном, например {‘name’: [1, 2], ‘make’: [3, 4]}


import json


def load_dct(dct, file):
     with open(file, 'w') as file:
         json.dump(dct, file, indent=2)

def some_func(*args, **kwargs):
    elems = len(args) // 5
    lst = []
    for i in range(5):
         first = i * elems
         last = first + elems if i < 5 - 1 else None
         lst.append(list(args[first: last]))
    return dict(zip(kwargs.values(), lst))

def main():
    file = 'HW_13_Domushchei.json'
    tpl = tuple(range(1, 22))
    dct = {'One': 'One', 'Two': 'Two', 'Three': 'Three', 'Four': 'Four', 'Five': 'Five'}
    res = some_func(*tpl, **dct)
    load_dct(res, file)

if __name__ == '__main__':
    main()
